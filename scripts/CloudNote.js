const {Node, Payload} = require("cloud-js");

const {Note, Layer, Entity, EntityValue} = require("./Note");
const CloudUtils = require("./CloudUtils");

const DeviceModel = require("./DeviceModel");

class CloudNote extends Note {
	constructor(data) {
		super(data);
	}

	getDocumentPayload() {
		return Payload.createUnique(CloudUtils.uuidToBuffer(this.id));
	}

	getPagePayload() {
		return Payload.createUnique(CloudUtils.uuidToBuffer(this.pageId));
	}

	toCloudNodes() {
		let documentNode = new Node(
			this.getDocumentPayload(),
			new Set(this.tags),
			new Map([
				["nodeType", "document"],
				["title", this.title],
				["creationDate", this.creationDate.toString()],
				["lastModifiedDate", this.lastModifiedDate.toString()],
				["stream", this.stream]
			])
		);

		let pageNode = new Node(
			this.getPagePayload(),
			new Set(),
			new Map([
				["nodeType", "page"],
				["creationDate", this.creationDate.toString()],
				["lastModifiedDate", this.lastModifiedDate.toString()],
				["transform", DeviceModel.getMatrixCloudAttr(this.transform)],
				["boundingBox", DeviceModel.getBoundingBoxCloudAttr(this.orientation, this.size)],
				["dpi", "100"],
				["locale", this.locale]
			])
		);

		return {
			pageNode,
			documentNode
		}
	}

	static fromCloudNodes(documentNode, pageNode) {
		const { attrs: documentAttrs, tags: documentTags, payload: documentPayload } = documentNode;
		const { attrs: pageAttrs, payload: pagePayload } = pageNode;

		let transform;

		try {
			transform = /^matrix\((.+)\)$/.exec(pageAttrs.get("transform"))[1].split(/ +/);

			if (transform.length != 6)
				throw new Error();

			transform = Module.MatTools.create({
				a:  parseFloat(transform[0]),
				b:  parseFloat(transform[1]),
				c:  parseFloat(transform[2]),
				d:  parseFloat(transform[3]),
				tx: parseFloat(transform[4]),
				ty: parseFloat(transform[5])
			})
		}
		catch (e) {
			throw new Error("Cannot parse transform:", transform);
		}

		let size;
		let boundingBox = /^rect\((.+)\)$/.exec(pageAttrs.get("boundingBox"))[1].split(/ +/);
		if (boundingBox.length != 4) throw new Error("Invalid bounding box:", boundingBox);

		let orientation = DeviceModel.getOrientation(transform);

		try {
			if (orientation == 0 || orientation == 2)
				size = {width: parseFloat(boundingBox[2]), height: parseFloat(boundingBox[3])};
			else
				size = {width: parseFloat(boundingBox[3]), height: parseFloat(boundingBox[2])};
		}
		catch (e) {
			throw new Error("Cannot parse boundingBox:", boundingBox);
		}

		return new CloudNote({
			id: CloudUtils.bufferToUuid(documentPayload.content),
			pageId: CloudUtils.bufferToUuid(pagePayload.content),
			title: documentAttrs.get("title") || "",
			creationDate: documentAttrs.get("creationDate") || Date.now(),
			lastModifiedDate: documentAttrs.get("lastModifiedDate") || Date.now(),
			transform,
			size,
			locale: pageAttrs.get("locale"),
			stream: documentAttrs.get("stream"),
			tags: [...documentTags]
		});
	}
}

class CloudLayer extends Layer {
	constructor(data) {
		super(data);
	}

	getLayerPayload() {
		return Payload.createUnique(CloudUtils.uuidToBuffer(this.id));
	}

	toCloudNode() {
		return new Node(
			this.getLayerPayload(),
			new Set(),
			new Map([
				["nodeType", "layer"],
				["lastModifiedDate", this.lastModifiedDate.toString()]
			])
		);
	}

	static fromCloudNode(cloudNode) {
		const {payload, attrs} = cloudNode;

		return new CloudLayer({
			id: CloudUtils.bufferToUuid(payload.content),
			lastModifiedDate: attrs.get("lastModifiedDate") || Date.now()
		})
	}

	strokesToCloudNodes() {
		return this.strokes.map(stroke => {
			let attrs = new Map();

			if (stroke.timestamp) attrs.set("creationDate", stroke.timestamp.toString());
			if (stroke.pointsRate) attrs.set("pointsPerSecond", stroke.pointsRate.toString());
			if (stroke.autoGeneratedPointsRate) attrs.set("autoGeneratedPointsRate", stroke.autoGeneratedPointsRate.toString());

			return new Node(Payload.create(Buffer.from(Module.InkEncoder.encode([stroke]))), new Set(), attrs);
		});
	}

	static strokesFromCloudNodes(cloudNodes) {
		if (!cloudNodes) return [];

		let strokes = Module.InkDecoder.decode(new Uint8Array(Buffer.concat(cloudNodes.map(cloudNode => cloudNode.payload.content))));

		cloudNodes.forEach((cloudNode, i) => {
			if (cloudNode.attrs.get("creationDate")) strokes[i].timestamp = parseInt(cloudNode.attrs.get("creationDate"));
			if (cloudNode.attrs.get("pointsPerSecond")) strokes[i].pointsRate = parseInt(cloudNode.attrs.get("pointsPerSecond"));
		});

		return strokes;
	}
}

class CloudEntity extends Entity {
	constructor(type, values) {
		super(type, values);
	}

	static getPayload(type) {
		let cloudType = "__" + type + "__";
		return Payload.createUnique(Buffer.from(cloudType));
	}

	getPayload() {
		return CloudEntity.getPayload(this.type);
	}

	toCloudNode() {
		return new Node(
			this.getPayload(),
			new Set(),
			new Map([
				["nodeType", "entity"],
				["lastModifiedDate", Date.now().toString()]
			]
		));
	}

	cloudValues() {
		return Object.values(this.values).map(value => value.toCloudNode());
	}

	static fromCloudNode(type, cloudValues) {
		// cloudNode.payload.content.toString()
		return new CloudEntity(type, cloudValues.map(cloudValue => CloudEntityValue.fromCloudNode(cloudValue)));
	}
}

class CloudEntityValue extends EntityValue {
	constructor(data) {
		super(data);
	}

	getPayload() {
		return Payload.create(CloudUtils.uuidToBuffer(this.id));
	}

	toCloudNode() {
		return new Node(
			this.getPayload(),
			new Set(this.notes.map(noteID => Payload.createUnique(CloudUtils.uuidToBuffer(noteID)).encodedData.toString("base64"))),
			new Map([
				["nodeType", this.type],
				["name", this.name],
				["stream", this.stream],
				["creationDate", this.creationDate.toString()]
			])
		);
	}

	static fromCloudNode(cloudNode) {
		const {payload, tags: base64Payloads, attrs} = cloudNode;

		let notes = [];

		for (let base64Payload of base64Payloads) {
			// let payload = Payload.createFromEncodedData(Buffer.from(base64Payload, "base64"));
			let payload;

			try {
				payload = Payload.createFromEncodedData(Buffer.from(base64Payload, "base64"));
			}
			catch(e) {
				console.warn(e.message)
				payload = Payload.createUnique(Buffer.from(base64Payload, "base64"));
			}

			notes.push(CloudUtils.bufferToUuid(payload.content));
		}

		return new CloudEntityValue({
			id: CloudUtils.bufferToUuid(payload.content),
			name: attrs.get("name"),
			stream: attrs.get("stream"),
			creationDate: attrs.get("creationDate"),
			notes: notes
		});
	}
}

global.notesContext = {
	Note: CloudNote,
	Layer: CloudLayer,
	Entity: CloudEntity,
	EntityValue: CloudEntityValue
};

module.exports = {CloudNote, CloudLayer, CloudEntity, CloudEntityValue};
