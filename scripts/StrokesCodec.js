let StrokesCodec = {
	encode(strokes) {
		return strokes.map(stroke => {
			let data = stroke.toJSON("BUFFER");
			data.timestamp = stroke.timestamp;
			data.pointsRate = stroke.pointsRate;
			data.autoGeneratedPointsRate = !!stroke.autoGeneratedPointsRate;

			return data;
		});
	},

	decode(brush, strokes) {
		return strokes.map(data => {
			let stroke = Module.Stroke.fromJSON(brush, data);

			if (data.timestamp) stroke.timestamp = data.timestamp;
			if (data.pointsRate) stroke.pointsRate = data.pointsRate;
			if (data.autoGeneratedPointsRate) stroke.autoGeneratedPointsRate = data.autoGeneratedPointsRate;

			return stroke;
		});
	},

	encodeRawLayers(rawLayers) {
		return rawLayers.map(rawLayer => {
			return rawLayer.map(rawPath => {
				return Object.assign({}, rawPath, {points: Buffer.from(rawPath.points.buffer).toJSON()});
			});
		});
	},

	decodeRawLayers(rawLayers) {
		return rawLayers.map(rawLayer => {
			return rawLayer.map(rawPath => {
				let buffer = Buffer.from(rawPath.points);
				let bytes = new Uint8Array(buffer);

				return Object.assign({}, rawPath, {points: new Float32Array(bytes.buffer)})
			});
		});
	}
};

module.exports = StrokesCodec;
