import uuid from 'uuid';

import {push} from 'react-router-redux';

import {addNotification} from './app';
import {filterByTag} from './library';
import {openDialog, closeDialog} from './modals';

import * as ActionTypes from '../constants/ActionTypes';
import * as Modals from '../constants/Modals';

import {Note, Layer} from '../../scripts/Note';
import PromiseQueue from '../../scripts/PromiseQueue';

const EMPTY_LANDSCAPE_THUMB = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHUAAABQCAYAAAAnZTo5AAAAO0lEQVR4Ae3BMQEAAADCIPunXgsvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwFkpAAAcCmfVcAAAAASUVORK5CYII=";
const EMPTY_PORTRAIT_THUMB = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAB1CAYAAADZcGYoAAAAO0lEQVR4Ae3BMQEAAADCIPunXg0PYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwJkrUAARgK5x4AAAAASUVORK5CYII=";

let queue = new PromiseQueue();

function toCamelCase(s) {
	return s.substring(0, 1).toUpperCase() + s.substring(1);
}

function updateLayer(strokes, initialDate) {
	let creationDate = initialDate || Date.now();
	let edit = false;

	let defaultPointsRate = 200;
	let pause = 1000;

	strokes.forEach(stroke => {
// console.log(stroke.timestamp, "("+stroke.originTimestamp+")", stroke.pointsRate, stroke.length, Math.ceil(stroke.length / (stroke.pointsRate || defaultPointsRate)  * 1000))
		if (!stroke.timestamp) {
			creationDate += pause;

			stroke.timestamp = creationDate;

			if (!stroke.pointsRate) {
				stroke.autoGeneratedPointsRate = true;
				stroke.pointsRate = defaultPointsRate;
			}

			creationDate += Math.ceil(stroke.length / stroke.pointsRate  * 1000);

			edit = true;
		}
	});

	return {creationDate, edit};
}

function initEditMode() {
	return (dispatch, getState) => {
		let {newNote} = getState().EditReducer;

		if (newNote) {
			let size = {width: 864, height: 1188};
			let orientation = 3;

			if (DeviceManager.device) {
				if (DeviceManager.device.size) size = DeviceManager.device.size;
				if ("orientation" in DeviceManager.device) orientation = DeviceManager.device.orientation;
			}

			let note = new Note({size: size, orientation: orientation, locale: LocalesManager.defaultNoteLocale, layers: [new Layer()]});
			note.onTouch = () => dispatch({type: ActionTypes.EDIT_NOTE_UPDATED});

			dispatch({type: ActionTypes.EDIT_MODE_INIT, body: note});
			dispatch(filterByTag());
		}
		else {
			let originalNote = ContentManager.getNote(ContentManager.selected.first);

			if (originalNote) {
				let note = Note.fromJSON(undefined, originalNote.toJSON([]));

				DBManager.getPageLayers(note.pageId)
					.then(layers => note.layers = layers)
					.then(() => {
						if (note.layers.length) {
							note.onTouch = () => dispatch({type: ActionTypes.EDIT_NOTE_UPDATED});
/*
							let creationDate = note.creationDate;
							let edit = false;

							note.layers.forEach(layer => {
// console.log("---------------------------------")
								let update = updateLayer(layer.strokes, creationDate);
// console.log("#####", layer.strokes.first.timestamp)
								creationDate = update.creationDate;
								edit = edit || update.edit;
							});

							let callback = () => dispatch({type: ActionTypes.EDIT_MODE_INIT, body: note});
// if (edit) console.log("...............save started........")
							if (edit)
								DBManager.editNote(note, callback);
							else
								callback();
*/
							dispatch({type: ActionTypes.EDIT_MODE_INIT, body: note});

							// SETTINGS if open
							dispatch(closeDialog());

							UAManager.edit("Edit Content", "Open Canvas");
						}
						else
							dispatch(push("/library"));
					});
			}
			else
				dispatch(push("/library"));
		}
	}
}

function saveNote() {
	return (dispatch, getState) => {
		let filterGroup = ContentManager.getEntity("groups").get(getState().LibraryReducer.filterGroup);
		let {saving, note} = getState().EditReducer;
		let {modal} = getState().AppReducer;

		if (!saving) {
			dispatch({type: ActionTypes.EDIT_START_SAVE});
			dispatch(toggleSaveButton(false));

			DBManager.editNotes([note]).then(() => {
				if (filterGroup && !filterGroup.notes.includes(note.id)) {
					filterGroup.addRelation(note.id);
					return DBManager.setEntity(ContentManager.getEntity("groups")).then(() => ContentManager.updateSections());
				}
				else
					return Promise.resolve();
			}).then(() => {
				dispatch({type: ActionTypes.EDIT_END_SAVE, body: note.id});
				dispatch(addNotification("notification.edit.noteSaved"));

				UAManager.edit("Edit Content", "Save Canvas");

				if (AppManager.closing)
					AppManager.confirmSaveNote();
			});
		}
	}
}

function toggleSaveButton(enabled) {
	return (dispatch, getState) => {
		dispatch({type: ActionTypes.EDIT_NOTE_SAVE_ENABLED, body: enabled});
	}
}

function triggerSaveNote() {
	return (dispatch, getState) => {
		let {saving, note, lastModifiedDate} = getState().EditReducer;

		if (note.lastModifiedDate != lastModifiedDate)
			dispatch(openDialog(Modals.SAVE_CHANGES));
		else if (!saving)
			AppManager.confirmSaveNote();
	}
}

function transferToLibrary() {
	return (dispatch, getState) => {
		let {saving, note, lastModifiedDate} = getState().EditReducer;

		dispatch(toggleSaveButton(false));

		if (note.lastModifiedDate != lastModifiedDate)
			dispatch(openDialog(Modals.SAVE_CHANGES));
		else
			dispatch(closeNote());
	}
}

function finalizeEditMode() {
	return (dispatch, getState) => {
		dispatch({type: ActionTypes.EDIT_MODE_FINALIZE});
	}
}

function selectLayer(layerIndex) {
	return (dispatch, getState) => {
		let {splitMode} = getState().EditReducer;

		if (!splitMode)
			dispatch({type: ActionTypes.EDIT_SELECT_LAYER, body: layerIndex});
	}
}

function addStrokeToCurrentLayer(stroke) {
	UAManager.edit("Edit Content", "Stroke Made");

	return (dispatch, getState) => {
		let {note, currentLayer} = getState().EditReducer;

		note.layers[currentLayer].addStroke(stroke);
		note.touch();
	}
}

function removeStrokesFromCurrentLayer(strokes) {
	return (dispatch, getState) => {
		let {note, currentLayer} = getState().EditReducer;

		strokes.forEach(stroke => note.layers[currentLayer].strokes.remove(stroke));

		note.layers[currentLayer].touch();
		note.touch();
	}
}

function selectTool(type) {
	UAManager.edit("Edit Content", "Select Tool " + toCamelCase(type));

	return (dispatch, getState) => {
		dispatch({type: ActionTypes.EDIT_TOOL_PICK, body: type});
	}
}

function toggleLayerPanel() {
	return (dispatch, getState) => {
		let {layerPaneVisible} = getState().EditReducer;

		if (layerPaneVisible) {
			UAManager.edit("Edit Content", "Layer Panel Closed");
			dispatch({type: ActionTypes.EDIT_HIDE_LAYER_PANE});
		}
		else {
			UAManager.edit("Edit Content", "Layer Panel Opened");
			dispatch({type: ActionTypes.EDIT_SHOW_LAYER_PANE});
		}
	}
}

function initNoteSplit() {
	UAManager.edit("Split Page", "Note Split Started");

	return (dispatch, getState) => {
		WILL.disableZoomAndPan();
		dispatch({type: ActionTypes.EDIT_INIT_SPLIT, body: {splitMode: "note"}});
	}
}

function initLayerSplit(targetLayer) {
	UAManager.edit("Split Page", "Layer Split Started");

	return (dispatch, getState) => {
		WILL.disableZoomAndPan();
		dispatch({type: ActionTypes.EDIT_INIT_SPLIT, body: {splitMode: "layer", targetLayer}});
	}
}

function cancelSplit() {
	return (dispatch, getState) => {
		let {splitMode} = getState().EditReducer;

		WILL.enableZoomAndPan();
		WILL.refreshLayers();

		dispatch({type: ActionTypes.EDIT_CANCEL_SPLIT});

		UAManager.edit("Split Page", toCamelCase(splitMode) + " Split Canceled");
	}
}

function applySplit() {
	return (dispatch, getState) => {
		let {note, currentLayer, splitMode, splitIndex, splitIndexMax, applyingSplitNote} = getState().EditReducer;

		if (splitMode == 'layer') {
			UAManager.edit("Split Page", "Layer Split Completed");

			if (splitIndex > 0 && splitIndex < splitIndexMax) {
				let newLayer = new Layer({ strokes: note.layers[currentLayer].strokes.slice(splitIndex) });
				note.layers[currentLayer].strokes = note.layers[currentLayer].strokes.slice(0, splitIndex);
				note.layers.splice(currentLayer + 1, 0, newLayer);

				note.layers[currentLayer].touch();
				note.touch();

				queue.then(() => {
					let previews = getState().EditReducer.previews;

					previews.splice(currentLayer + 1, 0, null);
					dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
				}).catch(console.error);

				dispatch({type: ActionTypes.EDIT_APPLY_SPLIT_LAYER});
				dispatch({type: ActionTypes.EDIT_LAYERS_CHANGED});

				dispatch(toggleSaveButton(true));
				dispatch(addNotification('notification.edit.layerSplit'));

				WILL.enableZoomAndPan();
			}
		}

		if (splitMode == 'note' && !applyingSplitNote) {
			if (splitIndex > 0 && splitIndex < splitIndexMax) {
				dispatch({type: ActionTypes.EDIT_BEGIN_SPLIT_NOTE});

				let strokesSoFar = 0;
				let previewSliceIndex = 0;

				let newNote = new Note({
					size: note.size,
					transform: note.transform,
					locale: note.locale,
					lastModifiedDate: Date.now(),
					tags: note.tags
				});

				for (let layerIndex = 0; layerIndex < note.layers.length; layerIndex++) {
					let strokes = note.layers[layerIndex].strokes;
					let layerSplitIndex = splitIndex - strokesSoFar;

					if (layerSplitIndex < strokes.length) {
						if (layerSplitIndex == 0) {
							newNote.layers = note.layers.slice(layerIndex);
							note.layers = note.layers.slice(0, layerIndex);

							previewSliceIndex = layerIndex;
						}
						else {
							newNote.layers = note.layers.slice(layerIndex);
							newNote.layers[0] = new Layer({ strokes: newNote.layers[0].strokes.slice(layerSplitIndex) });

							note.layers = note.layers.slice(0, layerIndex + 1);
							note.layers[note.layers.length - 1].strokes = note.layers[note.layers.length - 1].strokes.slice(0, layerSplitIndex);

							previewSliceIndex = layerIndex + 1;
						}

						break;
					}

					strokesSoFar += strokes.length;
				}

				// newNote.creationDate = newNote.layers.first.strokes.first.timestamp;
				newNote.creationDate = note.creationDate + note.strokes.length;

				note.layers.forEach(layer => layer.touch());
				note.touch();

				queue.then(() => {
					let previews = getState().EditReducer.previews;

					previews = previews.slice(0, previewSliceIndex);
					dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
				}).catch(console.error);

				newNote.layers.forEach(layer => { layer.id = uuid() });

				let noteID = note.id;
				note.renew();

				dispatch({type: ActionTypes.EDIT_START_SAVE});
				dispatch(toggleSaveButton(false));

				DBManager.editNotes([note, newNote]).then(() => {
					let noteGroups = ContentManager.getEntityRelations("groups", noteID);

					if (noteGroups.length > 0) {
						noteGroups.forEach(group => {
							group.addRelation(note.id);
							group.addRelation(newNote.id);
						});

						return DBManager.setEntity(ContentManager.getEntity("groups")).then(() => ContentManager.updateSections());
					}
					else
						return Promise.resolve();
				}).then(() => {
					ContentManager.select([note.id]);
					return DBManager.deleteNotes([noteID]);
				}).then(() => {
					UAManager.edit("Split Page", "Note Split Completed");

					dispatch({type: ActionTypes.EDIT_LAYERS_CHANGED});
					dispatch({type: ActionTypes.EDIT_APPLY_SPLIT_NOTE});
					dispatch(addNotification('notification.edit.noteSplit'));

					dispatch({type: ActionTypes.EDIT_END_SAVE, body: note.id});
					dispatch(addNotification("notification.edit.noteSaved"));

					WILL.enableZoomAndPan();
				});
			}
		}
	}
}

function setSplitIndex(value) {
	return (dispatch, getState) => {
		dispatch({type: ActionTypes.EDIT_SET_SPLIT_INDEX, body: value});
	}
}
/*
function generatePreviews() {
	return (dispatch, getState) => {
		let {note} = getState().EditReducer;
		note.layers.forEach((layer, index) => dispatch(updatePreview(index)));
	}
}
*/
function generatePreviewsPane() {
	return (dispatch, getState) => {
		let {note, previews} = getState().EditReducer;
		let emptyThumb = note.isLandscape() ? EMPTY_LANDSCAPE_THUMB : EMPTY_PORTRAIT_THUMB;

		note.layers.forEach((layer, index) => {
			previews[index] = (layer.strokes.length == 0) ? emptyThumb : null;
		});

		dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
	}
}

function updatePreview(...indexes) {
	return (dispatch, getState) => {
		let {note, previews} = getState().EditReducer;
		let emptyThumb = note.isLandscape() ? EMPTY_LANDSCAPE_THUMB : EMPTY_PORTRAIT_THUMB;
/*
		previews[index] = WILL.context2D.layers[index].toDataURL();
		dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
*/
		queue.then(() => {
			let previews = getState().EditReducer.previews;

			indexes.forEach(index => previews[index] = null);
			dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
		}).catch(console.error);;

		let exportLayerPreview = (index) => {
			let preview = new Note({size: note.size, transform: note.transform, locale: note.locale, layers: [note.layers[index]]});

			queue.then(() => {
				if (note.layers[index].strokes.length == 0) {
					let base64Image = emptyThumb.substring("data:image/png;base64,".length);
					return base64Image;
				}
				else
					return DBManager.exportLayerPreview(preview);
				return DBManager.exportLayerPreview(preview);
			}).then(base64Image => {
				let image = "data:image/png;base64," + base64Image;
				let previews = getState().EditReducer.previews;

				previews[index] = image;
				dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
				dispatch({type: ActionTypes.EDIT_PASTING, body: false});
			}).catch(console.error);
		};

		indexes.forEach(index => exportLayerPreview(index));
	}
}

function layerAdd() {
	return (dispatch, getState) => {
		let {note, previews} = getState().EditReducer;

		let layer = note.addLayer();
		note.touch();

		let targetLayer = note.layers.length - 1;

		if (note.isLandscape())
			previews.push(EMPTY_LANDSCAPE_THUMB);
		else
			previews.push(EMPTY_PORTRAIT_THUMB);

		dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
		dispatch({type: ActionTypes.EDIT_PASTE_LAYER, body: targetLayer});
		dispatch({type: ActionTypes.EDIT_LAYERS_CHANGED});
	}
}

function layerCopy(targetLayer) {
	UAManager.edit("Edit Content", "Copy Layer");

	return (dispatch, getState) => {
		let {note} = getState().EditReducer;
		let layer = note.layers[targetLayer].strokes;

		let clipboard = {
			id: note.id,
			size: note.size,
			transform: note.transform,
			strokes: Module.InkEncoder.encode(layer),
			meta: layer.map(stroke => ({timestamp: stroke.timestamp, pointsRate: stroke.pointsRate}))
		};

		dispatch({type: ActionTypes.EDIT_COPY_LAYER, body: clipboard});
	}
}

function layerPaste(targetLayer) {
	UAManager.edit("Edit Content", "Paste Layer");

	return (dispatch, getState) => {
		let {note, currentLayer, clipboard} = getState().EditReducer;

		if (currentLayer >= targetLayer)
			currentLayer += 1;

		let strokes = Module.InkDecoder.decode(clipboard.strokes);

		if (!Object.equals(note.transform, clipboard.transform)) {
			let transform = Module.MatTools.invert(note.transform);
			transform = Module.MatTools.multiply(transform, clipboard.transform);

			if (!Module.MatTools.isIdentity(transform))
				strokes.forEach(stroke => stroke.transform(transform))
				// strokes.forEach(stroke => stroke.super.transform(transform))
		}

		strokes.forEach((stroke, i) => {
			let meta = clipboard.meta[i];
			Object.keys(meta).forEach(key => (stroke[key] = meta[key]));
		});

		// updateLayer(strokes);

		note.layers.splice(targetLayer, 0, new Layer({ strokes }));
		note.touch();

		queue.then(() => {
			let previews = getState().EditReducer.previews;

			previews.splice(targetLayer, 0, null);
			dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
		}).catch(console.error);

		dispatch({type: ActionTypes.EDIT_PASTING, body: true});
		dispatch({type: ActionTypes.EDIT_PASTE_LAYER, body: targetLayer});
		dispatch({type: ActionTypes.EDIT_LAYERS_CHANGED});
	}
}

function layerDelete(targetLayer) {
	UAManager.edit("Edit Content", "Delete Layer");

	return (dispatch, getState) => {
		let {note, currentLayer} = getState().EditReducer;

		if (currentLayer >= targetLayer)
			currentLayer = Math.max(currentLayer - 1, 0);

		note.layers.splice(targetLayer, 1);
		note.touch();

		queue.then(() => {
			let previews = getState().EditReducer.previews;

			previews.splice(targetLayer, 1);
			dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
		}).catch(console.error);

		dispatch({type: ActionTypes.EDIT_DELETE_LAYER, body: currentLayer});
		dispatch({type: ActionTypes.EDIT_LAYERS_CHANGED});
	}
}

function layerMergePrevious(targetLayer) {
	UAManager.edit("Edit Content", "Merge Previous Layer");

	return (dispatch, getState) => {
		let {note, currentLayer} = getState().EditReducer;

		note.layers[targetLayer - 1].strokes = [...note.layers[targetLayer - 1].strokes, ...note.layers[targetLayer].strokes];
		note.layers.splice(targetLayer, 1);

		if (currentLayer >= targetLayer)
			currentLayer = Math.max(currentLayer - 1, 0);

		note.touch();
		note.layers[currentLayer].touch();

		queue.then(() => {
			let previews = getState().EditReducer.previews;

			previews.splice(targetLayer, 1);
			dispatch({type: ActionTypes.EDIT_UPDATE_PREVIEWS, body: previews});
		}).catch(console.error);

		dispatch({type: ActionTypes.EDIT_MERGE_PREVIOUS, body: currentLayer});
		dispatch(updatePreview(currentLayer));
		dispatch({type: ActionTypes.EDIT_LAYERS_CHANGED});
	}
}

function closeNote() {
	return (dispatch, getState) => {
		if (AppManager.closing)
			AppManager.confirmSaveNote();
		else {
			queue.cancel();
			dispatch(push('/library'));
		}
	}
}

export {
	initEditMode,
	saveNote,
	toggleSaveButton,
	triggerSaveNote,
	transferToLibrary,
	finalizeEditMode,
	selectLayer,
	addStrokeToCurrentLayer,
	removeStrokesFromCurrentLayer,
	selectTool,
	toggleLayerPanel,
	initNoteSplit,
	initLayerSplit,
	cancelSplit,
	applySplit,
	setSplitIndex,

	// generatePreviews,
	generatePreviewsPane,
	updatePreview,

	layerAdd,
	layerCopy,
	layerPaste,
	layerDelete,
	layerMergePrevious,

	closeNote
}
